/* autogenerated by Processing revision 1292 on 2023-08-04 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class test_main extends PApplet {

ArrayList<SPoint> points;
ArrayList<PVector> grid[][];
int dx, dy, dv = 10;

String filename = "trackpath.txt";

Map track;
                           // Keybinds
boolean Loop = false,      // q
        AddPoint = true,   // w
        DrawGrid = false,  // g
        DrawPoints = true; // c

public void setup() {
  /* size commented out by preprocessor */;
  dx = width / dv;
  dy = height / dv;
  
  reload();
  
  // Map
  track = new Map("HERO");
  track.loadFromFile("Track1.txt");
}

public void reload() {
  grid = new ArrayList[dx][dy];    // Grid for faster point selection
  for (int x = 0; x < dx; x++) {
    for (int y = 0; y < dy; y++) {
      grid[x][y] = new ArrayList<PVector>();
    }
  }
  
  points = new ArrayList<SPoint>();     // All SPoints
  loadSplines();    // From filename
}

public void addToGrid(PVector p) {
  grid[PApplet.parseInt(p.x/dv)][PApplet.parseInt(p.y/dv)].add(p);
}

public void removeFromGrid(PVector p) {
  int i = PApplet.parseInt(p.x / dv), j = PApplet.parseInt(p.y / dv);
  for (int _i = 0; _i < grid[i][j].size(); _i++) {
    if (p.dist(grid[i][j].get(_i)) == 0) grid[i][j].remove(_i);
  }
}

public PVector checkSelectedIn(int i, int j) {
  if (i < 0 || i > dx || j < 0 || j > dy) return null;
  if (grid[i][j].size() == 0) return null;
  
  PVector m = new PVector(mouseX, mouseY);
  for (PVector p: grid[i][j]) {
    if (p.dist(m) < 10) return p;
  }
  return null;
}

public PVector getPoint() {
  int x = mouseX / dv, y = mouseY / dv;
  for (int i = -1; i < 2; i++) {
    for (int j = -1; j < 2; j++) {
      PVector sel_point = checkSelectedIn(x+i, y+j);
      if (sel_point != null) return sel_point;
    }
  } return null;
}

PVector selectedPoint;
public void mousePressed() {
  if (!DrawPoints) return;
  
  selectedPoint = getPoint();
  if (selectedPoint != null) return;
  
  if (AddPoint) {points.add(new SPoint()); return;}
}

public void mouseDragged() {
  if (!DrawPoints) return;
  if (selectedPoint == null) return;
  selectedPoint.x = mouseX;
  selectedPoint.y = mouseY;
  
  removeFromGrid(selectedPoint);
  addToGrid(selectedPoint);
}

public void drawBezier(SPoint p1, SPoint p2){
  bezier(p1.cp.x, p1.cp.y,    // Anchor 1
         p1.c2.x, p1.c2.y,    // Control for Anchor 1
         p2.c1.x, p2.c1.y,    // Control for Anchor 2
         p2.cp.x, p2.cp.y);   // Anchor 2
}

public void drawCurve(){
  noFill();
  stroke(100, 200, 100);
  strokeWeight(2);
  
  for (int i = 0; i < points.size() - 1; i++) {
    SPoint p1 = points.get(i), p2 = points.get(i+1);
    drawBezier(p1, p2);
  }
  
  if (Loop){
    drawBezier(points.get(points.size() - 1), points.get(0));
  }
}

public void drawGrid() { 
  stroke(200);
  strokeWeight(1);
  for (int x = 0; x < width; x+=dv) {
    line(x, 0, x, height);
  }
  
  for (int y = 0; y < height; y+=dv) {
    line(0, y, width, y);
  }
}

public void hilightCell(){
  int x = mouseX / dv, y = mouseY / dv;
  noFill();
  stroke(255, 0, 0, 80);
  strokeWeight(3);
  rectMode(CORNER);
  
  for (int i = -1; i < 2; i++) {
    for (int j = -1; j < 2; j++) {
      square((x+i) * dv, (y+j) * dv, dv);
    }
  }
}

public void draw() {
  background(100);
  track.display();
  if (DrawGrid){
    drawGrid();
    hilightCell();
  }
  
  if (points.size() > 1){
    drawCurve();
  }
  
  if (DrawPoints){
    for (int i = 0; i < points.size(); i++){
      SPoint p = points.get(i);
      p.display();
      fill(0);
      textSize(14);
      text(i+1, p.cp.x, p.cp.y - 10);
    }
    
    // Hilight Selected Point
    PVector p = getPoint();
    if (p != null) {
    fill(0);
    circle(p.x, p.y, 10);
    }
  }
}

public void undo() {
  if (points.size() == 0) return;
  
  SPoint _p = points.get(points.size() - 1);
  removeFromGrid(_p.cp);
  removeFromGrid(_p.c1);
  removeFromGrid(_p.c2);
  
  points.remove(points.size() - 1);
}

public void keyPressed() {
  switch (key){
    case 'q':
      Loop = !Loop; break;
    case 'w':
      AddPoint = !AddPoint; break;
    case 'g':
      DrawGrid = !DrawGrid; break;
    case 'c':
      DrawPoints = !DrawPoints; break;
    case 's':
      savePathSpline(); break;
    case 'r':
      reload(); break;
    case 'z':
      undo(); break;
  }
}

public void loadSplines() {
  String splines[] = loadStrings(filename);
  if (splines == null) return;
  
  for (int i = 0; i < splines.length; i+=3){
    String cp[] = split(splines[i], ","),
           c1[] = split(splines[i+1], ","),
           c2[] = split(splines[i+2], ",");
    
    points.add(new SPoint(PApplet.parseInt(cp[0]), PApplet.parseInt(cp[1]),
                          PApplet.parseInt(c1[0]), PApplet.parseInt(c1[1]),
                          PApplet.parseInt(c2[0]), PApplet.parseInt(c2[1])));
    
  }
}


public void savePathSpline(){
  //File f;
  //while (true) {
  //  f = dataFile(filename + ".txt");
  //  if (!f.isFile()) break;
    
  //  filename = filename + "(1)";
  //}
  
  String splines[] = new String[points.size() * 3];
  for (int i = 0; i < points.size(); i++) {
    PVector cp = points.get(i).cp,
            c1 = points.get(i).c1,
            c2 = points.get(i).c2;
    
    int _i = i * 3;
    splines[_i] = "" + PApplet.parseInt(cp.x) + "," + PApplet.parseInt(cp.y); 
    splines[_i+1] = "" + PApplet.parseInt(c1.x) + "," + PApplet.parseInt(c1.y); 
    splines[_i+2] = "" + PApplet.parseInt(c2.x) + "," + PApplet.parseInt(c2.y);
  }
  
  saveStrings(filename, splines);
}
class Map {
  ArrayList<PVector> inside_edge, outside_edge;
  String name;
  Map (String name){
    this.name = name;
    this.resetTrack();
  }
  
  public void resetTrack(){
    this.inside_edge = new ArrayList<>();
    this.outside_edge = new ArrayList<>();
  }
  
  // File Functions
  public void loadFromFile(String fname) {
    // Load Map from file
    String savePoints[] = loadStrings(fname);
    if (savePoints != null) {
      this.resetTrack();
      
      int ni = PApplet.parseInt(savePoints[0]);
      for (int i = 1; i <= ni; i++){
        String s[] = split(savePoints[i], ",");
        int x = PApplet.parseInt(s[0]), y = PApplet.parseInt(s[1]);
        
        this.insert(true, new PVector(x, y));
      }
      
      for (int i = ni + 1; i < savePoints.length; i++){
        String s[] = split(savePoints[i], ",");
        int x = PApplet.parseInt(s[0]), y = PApplet.parseInt(s[1]);
        
        this.insert(false, new PVector(x, y));
      }
    }
  }
  
  public void dumpToFile(String fname) {
    // Dump map to file
    String savePoints[] = new String[1 + this.inside_edge.size()
                                      + this.outside_edge.size()];
    
    savePoints[0] = "" + this.inside_edge.size();
    int i = 1;
    for (PVector p: this.inside_edge) {
      savePoints[i++] = "" + p.x + "," + p.y;
    }
    
    for (PVector p: this.outside_edge) {
      savePoints[i++] = "" + p.x + "," + p.y;
    }
    
    saveStrings(fname, savePoints);
  }
  
  public void insert(Boolean edge, PVector point){
    if (edge){
      this.inside_edge.add(point);
    } else {
      this.outside_edge.add(point);
    }
  }
  
  public void display(){
    // Draw Inside Loop
    beginShape();
    for (PVector p: this.inside_edge){
      // Points
      fill(255);
      noStroke();
      circle(p.x, p.y, 10);
      
      // Line b/w points
      noFill();
      stroke(200, 50, 50);
      strokeWeight(2);
      vertex(p.x, p.y);
    } endShape();
    
    // Draw Outside Loop
    beginShape();
    for (PVector p: this.outside_edge){
      // Points
      fill(255);
      noStroke();
      circle(p.x, p.y, 10);
      
      // Line b/w points
      noFill();
      stroke(200, 50, 50);
      strokeWeight(2);
      vertex(p.x, p.y);
    } endShape();
  }
  
}
class SPoint {
  PVector c1, cp, c2;
  SPoint() {
    this.cp = new PVector(mouseX, mouseY);      // Anchor Point
    this.c1 = new PVector(mouseX - 50, mouseY); // Control point 1
    this.c2 = new PVector(mouseX + 50, mouseY); // Control point 2
    
    addToGrid(this.cp);
    addToGrid(this.c1);
    addToGrid(this.c2);
}
  
  SPoint(int x1, int y1, int x2, int y2, int x3, int y3){
    this.cp = new PVector(x1, y1);
    this.c1 = new PVector(x2, y2);
    this.c2 = new PVector(x3, y3);
    
    addToGrid(this.cp);
    addToGrid(this.c1);
    addToGrid(this.c2);
  }
  
  public void display() {
    strokeWeight(2);

    // Lines
    stroke(20);
    line(this.c1.x, this.c1.y, this.cp.x, this.cp.y);
    line(this.c2.x, this.c2.y, this.cp.x, this.cp.y);
    
    
    // Points
    stroke(200);
    
    // C1
    fill(0, 0, 255);
    circle(this.c1.x, this.c1.y, 10);
    
    // CP
    fill(255, 0, 0);
    circle(this.cp.x, this.cp.y, 15);
    
    // C2
    fill(0, 255, 0);
    circle(this.c2.x, this.c2.y, 10);
  }
  
}


  public void settings() { fullScreen(); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "test_main" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
